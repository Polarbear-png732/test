

event_queue.c
#include "server.h"
extern __thread pthread_mutex_t friend_lock;
extern __thread struct session_name client_session; // 线程局部变量存储客户端会话信息
extern __thread char **friends;
extern __thread char **online_friends; // 在线好友列表与好友列表和对应的好友数量
extern __thread int friend_count;
extern __thread int online_friend_count;

int push_event(EventQueue *queue, Event event)
{
    pthread_mutex_lock(&queue->mutex);

    if (queue->count == QUEUE_SIZE)
    {
        // 队列已满
        pthread_mutex_unlock(&queue->mutex);
        return -1;
    }

    queue->events[queue->tail] = event;
    queue->tail = (queue->tail + 1) % QUEUE_SIZE; // 环形缓冲区
    queue->count++;

    pthread_cond_signal(&queue->cond);
    pthread_mutex_unlock(&queue->mutex);
    return 0;
}

void stop_event_queue(EventQueue *queue)
{
    queue->stop = 10;                     // 设置停止标志
    pthread_cond_broadcast(&queue->cond); // 唤醒所有等待的线程
}

int pop_event(EventQueue *queue, Event *event)
{
    if (queue->stop == 10)
    {
        return 0;
    }

    pthread_mutex_lock(&queue->mutex);

    while (queue->count == 0 && queue->stop != 10)
    {
        pthread_cond_wait(&queue->cond, &queue->mutex);
    }

    // 如果队列已停止且为空，返回
    if (queue->count == 0 && queue->stop == 10)
    {
        pthread_mutex_unlock(&queue->mutex);
        return -1; // 或者其他表示停止的错误码
    }

    *event = queue->events[queue->head];

    queue->head = (queue->head + 1) % QUEUE_SIZE; // 环形缓冲区
    queue->count--;

    pthread_mutex_unlock(&queue->mutex);
    return 0;
}

// 初始化
void init_client_queues()
{
    for (int i = 0; i < MAX_CLIENTS; i++)
    {
        clientfd_queues_map[i].client_fd = -1;
        clientfd_queues_map[i].queue = NULL;
    }
}
void destroy_event_queue(EventQueue *queue)
{

    pthread_cond_destroy(&queue->cond);
    pthread_mutex_destroy(&queue->mutex);
}
// 销毁所有事件队列
void cleanup_client_queues()
{
    pthread_mutex_lock(&client_queues_lock);
    for (int i = 0; i < MAX_CLIENTS; i++)
    {
        if (clientfd_queues_map[i].queue)
        {
            destroy_event_queue(clientfd_queues_map[i].queue);
            free(clientfd_queues_map[i].queue);
        }
        clientfd_queues_map[i].client_fd = -1;
    }
    pthread_mutex_unlock(&client_queues_lock);
}
// 获取客户端事件队列
EventQueue *find_queue(int client_fd)
{
    pthread_mutex_lock(&client_queues_lock);

    // 查找现有队列
    for (int i = 0; i < MAX_CLIENTS; i++)
    {
        if (clientfd_queues_map[i].client_fd == client_fd)
        {
            pthread_mutex_unlock(&client_queues_lock);
            return clientfd_queues_map[i].queue; // 返回已存在的队列
        }
    }
    pthread_mutex_unlock(&client_queues_lock);
    return NULL; // 如果队列空间已满，返回 NULL
}

EventQueue *init_event_queue()
{
    EventQueue *queue = (EventQueue *)malloc(sizeof(EventQueue));
    pthread_mutex_init(&queue->mutex, NULL);
    pthread_cond_init(&queue->cond, NULL);
    queue->stop = 0;
    return queue;
}

void *process_events(void *arg)
{
    pthread_detach(pthread_self());
    event_pthread_arg *event_arg = (event_pthread_arg *)arg;
    EventQueue *queue = event_arg->queue;
    while (1)
    {
        if(queue->stop==10){
            return;
        }
        Event event;
        pop_event(queue, &event); // 从事件队列中获取事件
        if (event.event_type == 111)
        {
            update_online_friends(&event, event_arg);
        }
        else if (event.event_type == 222)
        {
            update_online_friends(&event, event_arg);
        }
        // 执行其他事件相关逻辑
    }
    return NULL;
}

void update_online_friends(Event *event, event_pthread_arg *event_arg)
{
    if (event->event_type == 111)
    {
        strncpy(event_arg->online_friends[*event_arg->online_friend_count], event->username, MAX_USERNAME_LENGTH - 1);
        (*event_arg->online_friend_count)++;
        printf("客户端：test，当前在线好友数量：%d\n", *event_arg->online_friend_count);
        for (int i = 0; i < *event_arg->online_friend_count; i++)
        {
            printf("%s  ", event_arg->online_friends[i]);
        }
        printf("\n");
    }
    if (event->event_type == 222)
    {

        for (int i = 0; i < *event_arg->online_friend_count; i++)
        {
            if (strcmp(event->username, event_arg->online_friends[i]) == 0) // 找到下线好友后，将之后的好友往前移，删除下线好友
            {
                for (int j = i; j < *event_arg->online_friend_count - 1; j++)
                {
                    strcpy(event_arg->online_friends[j], event_arg->online_friends[j + 1]);
                }
                break;
            }
        }
        (*event_arg->online_friend_count)--;
        printf("客户端：test，当前在线好友数量：%d\n", *event_arg->online_friend_count);
        for (int i = 0; i < *event_arg->online_friend_count; i++)
        {
            printf("%s  ", event_arg->online_friends[i]);
        }
        printf("\n");
    }
}





file_transfer.c
#include "server.h"

void offline_file_push(int client_fd, char *buffer, MYSQL *conn)
{

    OfflineFileData *filedata = offline_file_query(client_session.id, conn);
    if (filedata == NULL)
    {
        return;
    }
    char *file_name = strstr(filedata->offline_file[0], "文件路径："); // 只传一个文件。多个文件之后再扩展
    if (file_name != NULL)
    {
        file_name += strlen("文件路径："); // 跳过“文件路径：”这部分，直接指向文件路径的内容
    }
    filetransfer_req(client_fd, file_name);

    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    int client_file_fd = accept(file_sock, (struct sockaddr *)&client_addr, &client_len);
    pthread_mutex_lock(&client_queues_lock);
    file_transfer(client_file_fd, file_name);                                        // 发送给客户端的文件通过专门多套接字处理
    pthread_mutex_unlock(&client_queues_lock);
    free_offline_file(filedata);
    char query[512];
    snprintf(query, sizeof(query), "DELETE FROM offline_files where receiver_id='%d' ;", client_session.id);
    do_query(query, conn);
}
// 文件从服务器发送给客户端
void file_transfer(int client_fd, char *filename)
{
    long file_size = get_file_size(filename);
    float num = file_size / (BUFSIZE - 12);
    printf("文件大小：%ld,分为% .2f次传输\n", file_size, num);
    printf("文件名：%s\n", filename);
    FILE *file = fopen(filename, "rb");
    int block_number = 1;

    char buf[BUFSIZE];
    FileTransferResponse *ack = (FileTransferResponse *)buf;

    recv(client_fd, ack, 12, 0);
    printf("  块编号：%u,请求码：%u,len:%u\n", ntohl(ack->block_number), ntohl(ack->request_code), ntohl(ack->length));
    ack->request_code = htonl(RESPONSE_FILE_ACK);
    ack->length = htonl(12);
    while (1)
    {
        ack->block_number = htonl(block_number);
        size_t bytes_read;
        bytes_read = fread(buf + 12, 1, BUFSIZE - 12, file);
        ssize_t sent;
        sent = send(client_fd, buf, bytes_read + 12, 0);
        if (sent <= 0)
        {
            // 如果发送失败，打印详细的错误信息
            perror("Send error");
            printf("Error code: %d\n", errno);
            printf("Error description: %s\n", strerror(errno));
        }

        printf("sent:%lu\n", sent);
        recv(client_fd, ack, 12, 0);
        printf("第%u块\n", ntohl(ack->block_number));

        block_number++;
        if (feof(file))
        {
            printf("End of file reached.\n");
            break;
        }
    }
    fclose(file);
}

void file_recv(int client_fd, char *buffer, MYSQL *conn)
{
    FileTransferRequest *req = (FileTransferRequest *)buffer;
    unsigned int file_size = ntohl(req->file_size);
    char filename[256];
    char recver[32];
    char session[64];
    strcpy(session, req->session_token);
    snprintf(filename, sizeof(filename), "../server_file/%s", req->file_name);
    strcpy(recver, req->receiver_username); // 先存有用的信息, 传文件给另一个客户端用专门的缓冲区

    // 检查套接字是否可写
    fd_set writefds;
    struct timeval timeout;
    FD_ZERO(&writefds);
    FD_SET(client_fd, &writefds);
    timeout.tv_sec = 10; // 设置超时时间
    timeout.tv_usec = 0;
    int retval = select(client_fd + 1, NULL, &writefds, NULL, &timeout);
    if (retval == -1)
    {
        perror("select failed");
        return;
    }
    else if (retval == 0)
    {
        printf("套接字不可写，连接可能已关闭\n");
        return;
    }
    char buf[BUFSIZE];
    FILE *file = fopen(filename, "wb");

    FileTransferResponse *ack = (FileTransferResponse *)buf;

    ack->block_number = 0;
    ack->length = htonl(12);
    ack->request_code = htonl(RESPONSE_FILE_ACK); // 发送确认之后开始传文件
    send(client_fd, ack, 12, 0);
    int block_number = 1;
    int total_write = 0;
    while (1)
    {
        ssize_t bytes_recv = recv(client_fd, buf, BUFSIZE, 0);

        size_t bytes_write;
        bytes_write = fwrite(buf + 12, 1, bytes_recv - 12, file);
        total_write += bytes_write;
        printf("total_write%d\n", total_write);
        if (bytes_write == bytes_recv - 12)
        { // 写入成功，发送ack，开始下一轮接收
            ack->block_number = *(unsigned int *)(buf + 8);
            printf("第%u块接收完成\n", ntohl(ack->block_number));
            send(client_fd, ack, 12, 0);
        }
        if (total_write >= file_size)
        {
            printf("接收完毕\n");
            break;
        }
    }
    fclose(file);                  // 如果在线，调用转发文件多函数直接发过去给接受者
    if (online_query(recver) == 0) // 如用户不在线，现将文件信息存入数据库
    {
        int sender_id = client_session.id;
        int recver_id = find_id_mysql(recver, conn);

        char query[512];
        MYSQL_RES *result;
        MYSQL_ROW row;
        snprintf(query, sizeof(query), "INSERT INTO offline_files "
                                       "(sender_id,receiver_id,file_path) VALUES ('%d','%d','%s');",
                 sender_id, recver_id, filename);
        do_query(query, conn);
    }
    else
    {
        int index = find_session_index(1, recver);
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        filetransfer_req(session_table[index].client_fd, filename);
        int client_file_fd = accept(file_sock, (struct sockaddr *)&client_addr, &client_len);
        pthread_mutex_lock(&client_queues_lock);
        file_transfer(client_file_fd, filename); // 发送给客户端的文件通过专门多套接字处理
        pthread_mutex_unlock(&client_queues_lock);
        close(client_file_fd);
    }
}

long get_file_size(const char *filename)
{
    FILE *file = fopen(filename, "rb"); // 以二进制只读模式打开文件
    if (!file)
    {
        perror("Error opening file");
        return -1;
    }
    fseek(file, 0, SEEK_END);     // 移动文件指针到文件末尾
    long file_size = ftell(file); // 获取当前文件指针的位置，即文件大小
    fclose(file);                 // 关闭文件
    return file_size;
}

OfflineFileData *offline_file_query(int recver_id, MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;
    snprintf(query, sizeof(query), "SELECT u.username AS sender, of.file_path "
                                   "FROM offline_files of "
                                   "JOIN users u ON of.sender_id = u.id "
                                   "WHERE of.receiver_id = %d;",
             recver_id);
    result = do_query(query, conn);
    unsigned long num_rows = mysql_num_rows(result);
    if (num_rows == 0)
    {
        return NULL;
    }
    printf("Number of rows: %lu\n", num_rows);

    OfflineFileData *filedata = (OfflineFileData *)malloc(sizeof(filedata));

    int max_path_len = 64; // 文件路径最大长度
    char **offline_file = (char **)malloc(num_rows * sizeof(char *));
    if (offline_file == NULL)
    {
        printf("Memory allocation failed\n");
        return NULL;
    }

    int i = 0;
    for (i; i < num_rows; i++) // 分配空间存储查询到的离线文件信息
    {
        offline_file[i] = (char *)malloc(max_path_len * sizeof(char));
        if (offline_file[i] == NULL)
        {
            printf("Memory allocation failed for offline_file[%d]\n", i);
            return NULL;
        }
    }
    i = 0;
    while ((row = mysql_fetch_row(result)))
    {
        snprintf(offline_file[i], max_path_len, "发送者：%s,文件路径：%s", row[0], row[1]);
        i++;
    }
    filedata->num_files = num_rows;
    filedata->offline_file = offline_file;
    mysql_free_result(result);
    return filedata;
}

void free_offline_file(OfflineFileData *data)
{
    for (int i = 0; i < data->num_files; i++)
    {
        free(data->offline_file[i]);
    }
    free(data->offline_file);
    data->offline_file = NULL;
}

// 用于发送一个文件传输请求给客户端，接收确认之后开始调用函数传输文件
void filetransfer_req(int client_fd, char *filename)
{
    FileTransferRequest *req = (FileTransferRequest *)malloc(sizeof(FileTransferRequest));
    memset(req, 0, sizeof(FileTransferRequest));
    req->request_code = htonl(REQUEST_FILE_TRANSFER);
    req->length = htonl(sizeof(FileTransferRequest));
    long file_size = get_file_size(filename);
    printf("文件大小：%ld", file_size);
    req->file_size = htonl((unsigned int)file_size);

    filename = strstr(filename, "../server_file/"); // 只传一个文件。多个文件之后再扩展
    if (filename != NULL)
    {
        filename += strlen("../server_file/"); // 跳过“文件路径：”这部分，直接指向文件路径的内容
    }
    printf("%s\n", filename);
    strcpy(req->file_name, filename);

    ssize_t sent = send(client_fd, req, sizeof(FileTransferRequest), 0);
    printf("sent:%ld\n,", sent);
    free(req);
}




friend_manage.c
#include "server.h"
extern __thread pthread_mutex_t friend_lock;
extern __thread struct session_name client_session; // 线程局部变量存储客户端会话信息
extern __thread char **friends;
extern __thread char **online_friends; // 在线好友列表与好友列表和对应的好友数量
extern __thread int friend_count;
extern __thread int online_friend_count;
// 创建用户处理函数
void handle_create_user(int client_fd, char *buffer, MYSQL *conn)
{
    unsigned int len_response = sizeof(SimpleResponse);
    SimpleResponse *response = (SimpleResponse *)malloc(len_response);
    response->length = htonl(len_response);
    response->request_code = htonl(SIMPLE_RESPONSE);

    printf("handle create user\n");
    CreateUser *create_req = (CreateUser *)buffer;
    // 插入用户数据到数据库
    char query[512];
    snprintf(query, sizeof(query), "INSERT INTO users (username,password) VALUES ('%s','%s' );",
             create_req->username, create_req->password);

    if (mysql_query(conn, query))
    {
        response->status_code = htonl(FAIL);
        send(client_fd, response, len_response, 0);
        free(response);
        return;
    }

    // 返回成功响应
    response->status_code = htonl(SUCCESS);
    send(client_fd, response, len_response, 0);
    free(response);
    return;
}

// 处理添加或删除好友请求
void handle_add_friend(int client_fd, char *buffer, MYSQL *conn)
{
    FriendRequest *add_friend = (FriendRequest *)buffer;
    int i = find_session_index(0, add_friend->session_token);
    unsigned int user_id = 0;
    unsigned friend_id = 0;

    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;

    snprintf(query, sizeof(query),
             "SELECT id FROM users WHERE username='%s' OR username='%s' "
             "ORDER BY CASE username "
             "WHEN '%s' THEN 1 "
             "WHEN '%s' THEN 2 "
             "ELSE 3 END;",
             session_table[i].username,
             add_friend->friend_username,
             session_table[i].username,
             add_friend->friend_username);

    // 执行查询
    result = do_query(query, conn);
    if (result == NULL)
    {
        fprintf(stderr, "Store Result Error: %s\n", mysql_error(conn));
        return;
    }

    // 遍历结果集
    while ((row = mysql_fetch_row(result)))
    {
        if (user_id == 0)
        {
            user_id = atoi(row[0]);
        }
        else
        {
            friend_id = atoi(row[0]);
        }
    }
    printf("user_id:%d,  friend_id:%d\n", user_id, friend_id);

    if (ntohl(add_friend->action) == 0)
    {
        snprintf(query, sizeof(query), "DELETE FROM friends "
                                       "WHERE (user_id = %d AND friend_id = %d) OR (user_id = %d AND friend_id = %d);",
                 user_id, friend_id, friend_id, user_id);

        do_query(query, conn);
        return;
    }

    if (online_query(add_friend->friend_username)) // 用户在线，发送消息提醒
    {
        char message[128];
        int i = find_session_index(1, add_friend->friend_username);
        snprintf(message, sizeof(message), "收到来自%s的好友请求\n", client_session.username);
        send_message(session_table[i].client_fd, message);
    }
    // 如果用户不在线，数据插入到数据库，上线时推送
    snprintf(query, sizeof(query), "INSERT INTO friends (user_id, friend_id) VALUES ('%u','%u');",
             user_id, friend_id);
    do_query(query, conn);

    send_simple(client_fd, SUCCESS);
    mysql_free_result(result);
    return;
}

// 处理接受与拒绝添加好友的请求
void handle_accept_add(int client_fd, char *buffer, MYSQL *conn)
{
    HandleFriendRequest *handle_add = (HandleFriendRequest *)buffer;
    int i = find_session_index(0, handle_add->session_token);
    int friend_id = session_table[i].id; // 找到处理好友申请的用户id用于后续查询
    int user_id;
    int table_id; // 数据库中好友表的表项id
    char status[16];
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;

    if (ntohl(handle_add->action))
    {
        strcpy(status, "accepted");
    }
    else
    {
        strcpy(status, "blocked");
    }
    snprintf(query, sizeof(query),
             "SELECT id FROM users where username='%s'", handle_add->friend_username);

    result = do_query(query, conn);
    row = mysql_fetch_row(result);
    user_id = atoi(row[0]);
    mysql_free_result(result); // 释放结果集

    snprintf(query, sizeof(query),
             "SELECT id FROM friends where friend_id='%d' and user_id='%d';", friend_id, user_id);
    result = do_query(query, conn);
    row = mysql_fetch_row(result);
    table_id = atoi(row[0]);

    snprintf(query, sizeof(query),
             "UPDATE friends SET status = '%s' WHERE id='%d';", status, table_id);

    do_query(query, conn);

    send_simple(client_fd, SUCCESS);
    return;
}

// 推送好友请求
void push_friend(int client_fd, char *name, MYSQL *conn)

{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;
    snprintf(query, sizeof(query), "SELECT id FROM users WHERE username='%s'", name);
    result = do_query(query, conn);
    row = mysql_fetch_row(result);
    int friend_id = atoi(row[0]);
    mysql_free_result(result);
    snprintf(query, sizeof(query),
             "SELECT u.username "
             "FROM friends f "
             "JOIN users u ON f.user_id = u.id "
             "WHERE f.friend_id = %d AND f.status = 'pending';",
             friend_id);

    result = do_query(query, conn);

    char push_friend_message[256] = "新的好友：";
    int length = strlen(push_friend_message);

    while ((row = mysql_fetch_row(result)))
    {
        if (row[0] != NULL && strlen(row[0]) > 0)
        { // 检查 row[0] 是否为空
            strncat(push_friend_message, row[0], 32);
            strncat(push_friend_message, " ", 1);
            length = strlen(push_friend_message); // 更新 length
        }
    }
    printf("%s\n", push_friend_message);
    if (length > strlen("新的好友："))
    { // 检查是否有新的内容被添加
        send_message(client_fd, push_friend_message);
    }
    mysql_free_result(result);
    return;
}



void friend_remark(int client_fd, char *buffer, MYSQL *conn)
{
    FriendRemarkRequest *req = (FriendRemarkRequest *)buffer;
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;

    int user_id=find_id_mysql(client_session.username,conn);
    int friend_id=find_id_mysql(req->friendname,conn);
                                                                                                                                                                                                            
    snprintf(query,sizeof(query),"insert into friend_aliases (user_id,friend_id,alias) "
    "values(%d,%d,'%s')",user_id,friend_id,req->remark);
    do_query(query,conn);
    send_message(client_fd,"修改成功");
}





group_manage.c
#include "server.h"
extern __thread struct session_name client_session; // 线程局部变量存储客户端会话信息
extern __thread char **friends;
extern __thread char **online_friends; // 在线好友列表与好友列表和对应的好友数量
extern __thread int friend_count;
extern __thread int online_friend_count;
extern __thread pthread_mutex_t friend_lock;
void create_group(int client_fd, char *buffer, MYSQL *conn)
{
    GroupCreateRequest *group = (GroupCreateRequest *)buffer;
    int action = ntohl(group->action);
    int creator_id = find_uid(group->session_token);
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;

    if (action == 1)
    {

        snprintf(query, sizeof(query), "INSERT INTO groups (group_name,creator_id) "
                                       "VALUES ('%s','%d'); ",
                 group->group_name, creator_id);

        do_query(query, conn);
        int groupnum = get_groupnum(conn);
        int grou_id = find_group_id(group->group_name, conn);
        snprintf(query, sizeof(query), "INSERT INTO group_members (group_id,user_id) VALUES('%d','%d');", grou_id, creator_id);
        do_query(query, conn);
        add_group(groups, grou_id, group->group_name);
        add_member_to_group(groups, grou_id, group->group_name);

        return;
    }
    int groupnum = get_groupnum(conn);
    int grou_id = find_group_id(group->group_name, conn);
    snprintf(query, sizeof(query), "DELETE FROM groups "
                                   "where creator_id='%d' and group_name='%s'; ",
             creator_id, group->group_name);
    do_query(query, conn);
    dissolve_group(groups, grou_id);
    return;
}

void invite_to_group(int client_fd, char *buffer, MYSQL *conn)
{
    InviteRequest *invite = (InviteRequest *)buffer;
    int action = ntohl(invite->action);
    // 好友在线,直接转发邀请，否则先存入数据库
    int friend_index = find_session_index(1, invite->friendname);
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;

    snprintf(query, sizeof(query),
             "SELECT u.id AS user_id, g.id AS group_id "
             "FROM users u "
             "JOIN groups g "
             "WHERE u.username = '%s' AND g.group_name = '%s';",
             invite->friendname, invite->group_name);
    result = do_query(query, conn);
    row = mysql_fetch_row(result);
    int friend_id = atoi(row[0]);
    int group_id = atoi(row[1]);
    mysql_free_result(result);

    if (action == 0)
    { // 如果是删除成员的请求，删除并更新结构体数组
        snprintf(query, sizeof(query), "DELETE FROM group_members "
                                       "where group_id='%d and user_id='%d';",
                 group_id, friend_id);
        do_query(query, conn);
        int groupnum = get_groupnum(conn);
        remove_member_from_group(groups, group_id, invite->friendname);
        return;
    }
    snprintf(query, sizeof(query),
             "INSERT INTO  group_invites (group_id,sender_id,invitee_id) VALUES ('%d','%d','%d');",
             group_id, client_session.id, friend_id);
    do_query(query, conn);
    if (online_query(invite->friendname))
    {
        char group_invite[128];
        snprintf(group_invite, sizeof(group_invite),
                 "%s邀请你进入群聊：%s", client_session.username, invite->group_name);
        send_message(session_table[friend_index].client_fd, group_invite);
        return;
    }
}

// 用户上线时，从数据库中查询，群聊邀请，并推送给用户
void group_invite_push(int client_fd, MYSQL *conn)
{
    char query[512];
    char push[256];
    char temp[128];
    MYSQL_RES *result;
    MYSQL_ROW row;
    int invitee_id = client_session.id;
    snprintf(query, sizeof(query),
             "SELECT u.username AS inviter_name, g.group_name "
             "FROM group_invites gi "
             "JOIN groups g ON gi.group_id = g.id "
             "JOIN users u ON gi.sender_id = u.id "
             "WHERE gi.invitee_id = %d AND gi.status = 'pending' "
             "ORDER BY u.username ASC, g.group_name ASC;",
             invitee_id);
    result = do_query(query, conn);
    int num_rows = (int)mysql_num_rows(result);
    if (num_rows == 0)
    {
        return;
    }
    while (row = mysql_fetch_row(result))
    {
        snprintf(temp, sizeof(temp), "%s邀请你进入群聊%s\n", row[0], row[1]);
        strcat(push, temp);
    }
    mysql_free_result(result);
    printf("%s\n", push);
    send_message(client_fd, push);
}

// 处理同意和拒绝进群的请求
void handle_add_group(int client_fd, char *buffer, MYSQL *conn)
{
    // 根据请求报文中的群聊名称，和会话标识符，找到对应的用户的记录，将群聊邀请状态改为接受
    // 再将用户插入到对应的群组成员表中

    HandleGroupInvite *handle_group = (HandleGroupInvite *)buffer;
    int action = ntohl(handle_group->action);
    char status[16];
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;

    int grou_id = find_group_id(handle_group->group_name, conn);
    int invitee_id = client_session.id;
    if (action)
    {
        strcpy(status, "accepted");
        snprintf(query, sizeof(query),
                 "UPDATE group_invites "
                 "SET status= '%s' "
                 "where group_id=%d and invitee_id=%d;",
                 status, grou_id, invitee_id);
        do_query(query, conn);
        snprintf(query, sizeof(query),
                 "INSERT INTO group_members (group_id,user_id) VALUES(%d,%d);", grou_id, invitee_id);
        do_query(query, conn);
        int groupnum = get_groupnum(conn);
        add_member_to_group(groups, grou_id, client_session.username);
        print_groups(groups, conn);
    }
    else
    {
        strcpy(status, "rejected");
        snprintf(query, sizeof(query),
                 "UPDATE group_invites "
                 "SET status= '%s' "
                 "where group_id=%d and invitee_id=%d;",
                 status, grou_id, invitee_id);
        do_query(query, conn);
    }
}
// 从数据库中查询某个群的id
int find_group_id(char *groupname, MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;
    int group_id;
    snprintf(query, sizeof(query),
             "SELECT id FROM groups where group_name='%s';", groupname);
    result = do_query(query, conn);
    row = mysql_fetch_row(result);
    group_id = atoi(row[0]);
    mysql_free_result(result);
    return group_id;
}
// 处理发送群聊消息的请求
void group_message(int client_fd, char *buffer, MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;

    GroupMessage *message = (GroupMessage *)buffer;
    unsigned int group_id = ntohl(message->group_id);
    int sender_id = find_uid(message->session_token);

    snprintf(query, sizeof(query), // 先将消息插入群聊消息表
             "INSERT INTO group_messages (group_id,sender_id,message) VALUES ('%u','%d','%s'); ",
             group_id, sender_id, message->message);
    do_query(query, conn);
    online_groupmembers(groups, group_id, online_members); // 找到群中除了发消息者之外在线的人，并转发群消息
    for (int i = 0; i < MAX_MEMBERS; i++)
    {
        if (strcmp(online_members[i], client_session.username) == 0 || strcmp(online_members[i], "") == 0) // 是发送这或者为空,跳过
        {
            continue;
        }
        int index = find_session_index(1, online_members[i]);
        char group_message[512];
        snprintf(group_message, sizeof(group_message), "来自'%s'群聊消息：%s\n", client_session.username, message->message);
        send_message(session_table[index].client_fd, group_message);
    }
}
void online_groupmembers(Group *groups, int group_id, char (*members)[MAX_USERNAME_LENGTH])
{

    for (int i = 0; i < MAX_MEMBERS; i++)
    {
        if (groups[i].group_id == group_id)
            for (int j = 0; j < groups[i].member_count; j++)
            {
                if (online_query(groups[i].members[j]))
                {
                    strcpy(online_members[j], groups[i].members[j]);
                }
            }
    }
}

// 获取当前群组数量
int get_groupnum(MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;
    strcpy(query, "SELECT COUNT(DISTINCT id) FROM groups;");
    result = mysql_query(conn, query) == 0 ? mysql_store_result(conn) : NULL;
    if (!result)
    {
        return -1;
    }
    row = mysql_fetch_row(result);
    int group_num = row ? atoi(row[0]) : 0;
    mysql_free_result(result);
    return group_num;
}

// 获取群组成员
void get_groupmember(Group *groups, MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;
    snprintf(query, sizeof(query),
             "SELECT g.id AS group_id, g.group_name, gm.user_id, u.username "
             "FROM groups g JOIN group_members gm ON g.id = gm.group_id "
             "JOIN users u ON gm.user_id = u.id "
             "ORDER BY g.id, gm.user_id;");
    result = mysql_query(conn, query) == 0 ? mysql_store_result(conn) : NULL;
    if (!result)
    {
        return;
    }

    int group_index = -1;
    int group_id = -1;

    while ((row = mysql_fetch_row(result)))
    {
        int current_group_id = atoi(row[0]);

        // 检查是否是新的群组
        if (current_group_id != group_id)
        {
            group_id = current_group_id;
            group_index++;
            groups[group_index].group_id = current_group_id;
            strncpy(groups[group_index].group_name, row[1], sizeof(groups[group_index].group_name) - 1);
            groups[group_index].group_name[sizeof(groups[group_index].group_name) - 1] = '\0'; // 确保字符串结尾
            groups[group_index].member_count = 0;                                              // 初始化成员计数
        }

        // 添加成员到当前群组
        int member_index = groups[group_index].member_count;
        if (member_index < MAX_MEMBERS)
        {
            strncpy(groups[group_index].members[member_index], row[3], MAX_USERNAME_LENGTH - 1);
            groups[group_index].members[member_index][MAX_USERNAME_LENGTH - 1] = '\0'; // 确保字符串结尾
            groups[group_index].member_count++;
        }
    }

    mysql_free_result(result);
}

// 添加成员到群组
int add_member_to_group(Group *groups, unsigned int group_id, const char *username)
{
    for (int i = 0; i < 10; i++)
    {
        if (groups[i].group_id == group_id)
        {
            // 检查是否有足够的空间加入新成员
            if (groups[i].member_count < MAX_MEMBERS)
            {
                // 确保成员名不重复
                for (int j = 0; j < groups[i].member_count; j++)
                {
                    if (strcmp(groups[i].members[j], username) == 0)
                    {
                        return 0; // 用户已经是群组成员
                    }
                }
                // 加入新成员
                strncpy(groups[i].members[groups[i].member_count], username, MAX_USERNAME_LENGTH - 1);
                groups[i].members[groups[i].member_count][MAX_USERNAME_LENGTH - 1] = '\0'; // 确保字符串结尾
                groups[i].member_count++;
                return 1; // 成员加入成功
            }
            return 0; // 群组已满，无法加入新成员
        }
    }
    return 0; // 找不到指定的群组
}

// 从群组中移除成员
int remove_member_from_group(Group *groups, unsigned int group_id, const char *username)
{
    for (int i = 0; i < 10; i++)
    {
        if (groups[i].group_id == group_id)
        {
            for (int j = 0; j < groups[i].member_count; j++)
            {
                if (strcmp(groups[i].members[j], username) == 0)
                {
                    // 找到成员并将其移除
                    for (int k = j; k < groups[i].member_count - 1; k++)
                    {
                        strcpy(groups[i].members[k], groups[i].members[k + 1]);
                    }
                    groups[i].member_count--;
                    return 1; // 成员移除成功
                }
            }
            return 0; // 成员未找到
        }
    }
    return 0; // 找不到指定的群组
}

// 添加新群组
int add_group(Group *groups, unsigned int group_id, const char *group_name)
{
    // 检查是否已经有10个群组
    for (int i = 0; i < 10; i++)
    {
        if (groups[i].group_id == 0)
        { // 0 表示空的群组
            groups[i].group_id = group_id;
            strncpy(groups[i].group_name, group_name, sizeof(groups[i].group_name) - 1);
            groups[i].group_name[sizeof(groups[i].group_name) - 1] = '\0'; // 确保字符串结尾
            groups[i].member_count = 0;
            return 1; // 群组创建成功
        }
    }
    return 0; // 群组已满，无法创建新群组
}

// 删除群组
int dissolve_group(Group *groups, unsigned int group_id)
{
    for (int i = 0; i < 10; i++)
    {
        if (groups[i].group_id == group_id)
        {
            groups[i].group_id = 0; // 通过设置 group_id 为 0 来标记群组已解散
            groups[i].member_count = 0;
            return 1; // 群组解散成功
        }
    }
    return 0; // 找不到指定的群组
}

void print_groups(Group *groups, MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;

    // SQL 查询语句
    snprintf(query, sizeof(query),
             "SELECT g.id AS group_id, g.group_name, gm.user_id, u.username "
             "FROM groups g JOIN group_members gm ON g.id = gm.group_id "
             "JOIN users u ON gm.user_id = u.id "
             "ORDER BY g.id, gm.user_id;");

    // 执行查询
    result = mysql_query(conn, query) == 0 ? mysql_store_result(conn) : NULL;
    if (!result)
    {
        fprintf(stderr, "Query execution failed or no results.\n");
        return;
    }

    int group_index = -1;
    int group_id = -1;

    // 遍历查询结果
    while ((row = mysql_fetch_row(result)))
    {
        int current_group_id = atoi(row[0]);

        // 检查是否是新的群组
        if (current_group_id != group_id)
        {
            group_id = current_group_id;
            group_index++;
            groups[group_index].group_id = current_group_id;
            strncpy(groups[group_index].group_name, row[1], sizeof(groups[group_index].group_name) - 1);
            groups[group_index].group_name[sizeof(groups[group_index].group_name) - 1] = '\0'; // 确保字符串结尾
            groups[group_index].member_count = 0;                                              // 初始化成员计数
        }

        // 添加成员到当前群组
        int member_index = groups[group_index].member_count;
        if (member_index < MAX_MEMBERS)
        {
            strncpy(groups[group_index].members[member_index], row[3], MAX_USERNAME_LENGTH - 1);
            groups[group_index].members[member_index][MAX_USERNAME_LENGTH - 1] = '\0'; // 确保字符串结尾
            groups[group_index].member_count++;
        }
    }

    // 打印群组信息
    for (int i = 0; i <= group_index; i++)
    {
        printf("Group ID: %u, Group Name: %s, Members (%d):\n",
               groups[i].group_id,
               groups[i].group_name,
               groups[i].member_count);

        for (int j = 0; j < groups[i].member_count; j++)
        {
            printf("  - %s\n", groups[i].members[j]);
        }
    }

    // 释放查询结果
    mysql_free_result(result);
}

// 查询某个用户加入的群和群成员，群主, 并推送给用户
void users_group_query(int client_fd, int user_id, MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;
    snprintf(query, sizeof(query), "select group_id from group_members where user_id=%d;", user_id);

    result = do_query(query, conn);
    int num_rows = (int)mysql_num_rows(result);

    int group[num_rows];
    int i = 0;
    while ((row = mysql_fetch_row(result)))
    {
        group[i] = atoi(row[0]);
        i++;
    }
    mysql_free_result(result);
    char group_push[512] = {0};
    for (i = 0; i < num_rows; i++)
    {
        snprintf(query, sizeof(query),
                 "SELECT "
                 "g.group_name, "
                 "u.username AS member_name, "
                 "u_creator.username AS creator_name "
                 "FROM "
                 "groups g "
                 "JOIN group_members gm ON g.id = gm.group_id "
                 "JOIN users u ON gm.user_id = u.id "
                 "JOIN users u_creator ON g.creator_id = u_creator.id "
                 "WHERE "
                 "g.id = %d;",
                 group[i]);
        result = do_query(query, conn);
        int j = 0;

        while ((row = mysql_fetch_row(result)))
        {
            if (j == 0)
            {
                int len = strlen(group_push);
                snprintf(group_push + len, sizeof(group_push) - len, "群聊:%s  id：%d\n", row[0], group[i]);
            }
            strcat(group_push, row[1]);
            if(strcmp(row[1],row[2])==0){
                strcat(group_push,"（群主）");
            }
            strcat(group_push, "\n");
            j++;
        }
        mysql_free_result(result);
    }
    printf("%s\n", group_push);
    send_message(client_fd, group_push);
}

void groupname_reset(int client_fd,char *buffer,MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;
    GroupNameRestet*req=( GroupNameRestet*)buffer;
    unsigned int group_id=ntohl(req->group_id);

    snprintf(query,sizeof(query),"select creator_id from groups where id=%u;",group_id);
    result=do_query(query,conn);
    row = mysql_fetch_row(result);
    unsigned int creator=atoi(row[0]);

    if(creator!=client_session.id){
        send_message(client_fd,"只有群主才能修改！\n");
    }
    mysql_free_result(result);
    snprintf(query,sizeof(query),"update groups set group_name='%s' where id=%d",req->group_newname,group_id);
    do_query(query,conn);
    send_message(client_fd,"修改成功");
}










init.c
#include "server.h"

// 初始化服务器套接字
int init_server()
{
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1)
    {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    int opt = 1; // 设置SO_REUSEADDR选项的值
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1)
    {
        perror("Setsockopt failed");
        exit(EXIT_FAILURE);
    }
    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1)
    {
        perror("Bind failed");
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, MAX_CLIENT) == -1)
    {
        perror("Listen failed");
        exit(EXIT_FAILURE);
    }

    return server_fd;
}

int init_file_transfer_server()
{
   int file_transfer_server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (file_transfer_server_fd == -1)
    {
        perror("File transfer socket creation failed");
        exit(EXIT_FAILURE);
    }
    int opt = 1;

    if (setsockopt(file_transfer_server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1)
    {
        perror("Setsockopt failed");
        exit(EXIT_FAILURE);
    }
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(FILE_TRANSFER_PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(file_transfer_server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1)
    {
        perror("File transfer bind failed");
        exit(EXIT_FAILURE);
    }

    if (listen(file_transfer_server_fd, MAX_CLIENT) == -1)
    {
        perror("File transfer listen failed");
        exit(EXIT_FAILURE);
    }

    return file_transfer_server_fd;
}





main.c
#include "server.h"

struct session_name session_table[10];
int session_table_index = 0;
ClientEventQueueMap clientfd_queues_map[MAX_CLIENTS];
int map_index = 0;
pthread_mutex_t client_queues_lock = PTHREAD_MUTEX_INITIALIZER;
Group groups[10] = {0};
int file_sock;
int main()
{
    // 初始化
    int server_fd = init_server();
    file_sock = init_file_transfer_server();
    printf("Server started, waiting for connections...\n");
    init_client_queues();

    // 循环接受客户端连接，并为每个客户端创建一个新线程
    while (1)
    {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        int client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &client_len);
        if (client_fd < 0)
        {
            perror("Failed to accept connection");
            continue;
        }
        // 创建一个线程处理该客户端
        pthread_t tid;
        pthread_create(&tid, NULL, handle_client, (void *)&client_fd);
    }

    return 0;
}





server.c
#include "server.h"

__thread pthread_mutex_t friend_lock = PTHREAD_MUTEX_INITIALIZER;
__thread char **friends = NULL;
__thread char **online_friends = NULL; // 在线好友列表与好友列表和对应的好友数量
__thread int friend_count = 0;
__thread int online_friend_count = 0;
__thread struct session_name client_session;
__thread EventQueue *queue = NULL;
char online_members[MAX_MEMBERS][MAX_USERNAME_LENGTH] = {0};
// 请求处理函数
void *handle_client(void *arg)
{
    pthread_detach(pthread_self());
    pthread_t main_thread = pthread_self();
    pthread_t *queue_pthread = (pthread_t *)malloc(sizeof(pthread_t));
    event_pthread_arg *event_arg = NULL;
    queue = init_event_queue();

    int client_fd = *(int *)arg;
    char buffer[BUFSIZE];
    MYSQL *conn = db_connect();
    if (!conn)
    {
        printf("数据库连接失败！\n");
        close(client_fd);
        return NULL;
    }
    get_groupmember(groups, conn);
    unsigned int req_length;
    unsigned int size_len = sizeof(unsigned int);

    // 设置接收超时时间为 10 秒
    struct timeval timeout;
    timeout.tv_sec = 300; // 超时时间秒数
    timeout.tv_usec = 0;  // 微秒部分
    setsockopt(client_fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout));

    printf("client connection!\n");

    while (1)
    {
        if (recv_full(client_fd, buffer, size_len) <= 0) // 接收报文长度
        {
            if (errno == EWOULDBLOCK || errno == EAGAIN)
            {
                printf("客户端 10 秒未发送请求，下线处理。\n");
            }
            else
            {
                printf("接收报文长度失败或客户端断开！\n");
                on_off_push(0);
                delete_client_map(client_session.client_fd);
                delete_session(client_session.session);
            }
            break;
        }
        else
        {
            printf("Received length field: %u bytes\n", ntohl(*(unsigned int *)buffer));
        }
        req_length = ntohl(*(unsigned int *)buffer);

        if (recv_full(client_fd, buffer + size_len, req_length - size_len) > 0) // 接收剩余的数据
        {
            printf("Received full message of %u bytes\n", req_length);
        }
        else
        {
            printf("Failed to receive full message\n");
        }
        // 解析请求类型
        unsigned int request_code = ntohl(*(unsigned int *)(buffer + size_len));
        switch (request_code)
        {
        case REQUEST_LOGIN:
            handle_login(client_fd, buffer, conn, queue_pthread, event_arg);
            break;
        case REQUEST_CREATEUSER:
            handle_create_user(client_fd, buffer, conn);
            break;
        case REQUEST_ADD_FRIEND:
            handle_add_friend(client_fd, buffer, conn);
            break;
        case REQUEST_HANDELE_ADD:
            handle_accept_add(client_fd, buffer, conn);
            break;
        case REQUEST_POLLING:
        {
            Polling *p = (Polling *)buffer;
            int polling = find_session_index(0, p->token);
            // push_friend(client_fd, session_table[polling].username, conn);
            break;
        }
        case REQUEST_PRIVATE_MESSAGE:
            private_message(client_fd, buffer, conn);
            break;
        case REQUEST_CREATE_GROUP:
            create_group(client_fd, buffer, conn);
            break;
        case REQUEST_INVITE_TOGROUP:
            invite_to_group(client_fd, buffer, conn);
            break;
        case REQUEST_HANDLE_GROUP:
            handle_add_group(client_fd, buffer, conn);
            break;
        case CLIENT_EXIT:
            clietn_exit(queue_pthread, event_arg, client_fd, conn);
            break;
        case REQUEST_GROUP_MESSAGE:
            group_message(client_fd, buffer, conn);
            break;
        case REQUEST_FILE_TRANSFER:
            file_recv(client_fd, buffer, conn);
            break;
        case REQUEST_GROUPNAME_RESET:
            groupname_reset(client_fd, buffer, conn);
            break;
        case REQUEST_FRIEND_REMARK:
            friend_remark(client_fd, buffer, conn);
            break;

        default:
            printf("未知的请求代码: %u\n", request_code);
            break;
        }
    }
    return NULL;
}

// 登录处理函数
void handle_login(int client_fd, char *buffer, MYSQL *conn, pthread_t *queue_pthread, event_pthread_arg *event_arg)
{
    LoginRequest *login_req = (LoginRequest *)buffer;

    // 查询数据库，验证用户名和密码
    char query[256];

    snprintf(query, sizeof(query), "SELECT * FROM users WHERE username='%s' AND password='%s'",
             login_req->username, login_req->password);
    MYSQL_RES *res = do_query(query, conn);
    if (mysql_num_rows(res) == 0)
    {
        send_message(client_fd, "Invalid username or password");
        mysql_free_result(res);
        return;
    }
    // 获取id
    MYSQL_ROW row = mysql_fetch_row(res);
    unsigned int user_id = atoi(row[0]);
    // 登录成功，生成会话标识符

    LoginResponse login_res;
    login_res.status_code = htonl(SUCCESS);
    login_res.length = htonl(sizeof(login_res));
    login_res.request_code = htonl(RESPONSE_LOGIN);
    generate_session_id(login_res.session_token);
    strcpy(login_res.offline_messages, "no offline messige");

    send(client_fd, &login_res, sizeof(login_res), 0);

    client_session.client_fd = client_fd; // 保存用户会话
    client_session.id = user_id;
    strncpy(client_session.username, login_req->username, MAX_USERNAME_LENGTH - 1);
    client_session.username[MAX_USERNAME_LENGTH - 1] = '\0';
    strncpy(client_session.session, login_res.session_token, TOKEN_LEN - 1);
    client_session.session[TOKEN_LEN - 1] = '\0';

    // 存储客户端文件描述符和事件队列的映射关系
    pthread_mutex_lock(&client_queues_lock);
    clientfd_queues_map[map_index].client_fd = client_fd;
    clientfd_queues_map[map_index].queue = queue;
    map_index++;
    pthread_mutex_unlock(&client_queues_lock);

    // 保存会话标识符与用户名和id的映射
    store_session(login_req->username, login_res.session_token, user_id, client_fd);
    mysql_free_result(res);
    push_friend(client_fd, login_req->username, conn);

    // 获取好友列表
    friends = get_friend_list(user_id, &friend_count, conn);
    push_fri_list(friends, friend_count, client_fd, conn);
    online_friends = get_online_friends(friends, &friend_count, &online_friend_count);
    printf("客户端：%s登录时在线好友数量%d\n", client_session.username, online_friend_count);

    pthread_t event_thread;

    event_arg = (event_pthread_arg *)malloc(sizeof(event_pthread_arg));
    event_arg->online_friends = online_friends;
    event_arg->queue = queue;
    event_arg->online_friend_count = &online_friend_count;
    event_arg->friend_count = &friend_count;
    event_arg->friends = friends;
    // 创建线程处理事件队列
    pthread_create(&event_thread, NULL, process_events, (void *)event_arg);

    *queue_pthread = event_thread;

    // 上线时推送消息
    group_invite_push(client_fd, conn);
    users_group_query(client_session.client_fd, client_session.id, conn);
    offline_message_push(user_id, conn);
    on_off_push(1);

    // 推送离线文件
    offline_file_push(client_fd, buffer, conn);
}

// 数据库连接函数
MYSQL *db_connect()
{
    MYSQL *conn = mysql_init(NULL);
    if (!conn)
    {
        perror("MySQL initialization failed");
        exit(EXIT_FAILURE);
    }

    if (!mysql_real_connect(conn, "localhost", "polarbear", "polarbear", "chat_app", 0, NULL, 0))
    {
        perror("MySQL connection failed");
        exit(EXIT_FAILURE);
    }

    return conn;
}

// 存储会话标识符与用户名的映射
void store_session(const char *username, const char *session_token, unsigned int id, int client_fd)
{
    // 确保不会越界
    if (session_table_index < 10)
    {
        // 使用 strncpy 避免溢出
        strncpy(session_table[session_table_index].username, username, sizeof(session_table[session_table_index].username) - 1);
        session_table[session_table_index].username[sizeof(session_table[session_table_index].username) - 1] = '\0'; // 保证字符串以 '\0' 结尾

        strncpy(session_table[session_table_index].session, session_token, sizeof(session_table[session_table_index].session) - 1);
        session_table[session_table_index].session[sizeof(session_table[session_table_index].session) - 1] = '\0'; // 保证字符串以 '\0' 结尾

        session_table[session_table_index].id = id;
        session_table[session_table_index].client_fd = client_fd;
        session_table_index++;
    }
    else
    {
        // 如果会话表已满，输出错误信息或处理方式
        printf("Error: Session table is full.\n");
    }
}
// 保证接收完整
int recv_full(int sock, void *buf, size_t len)
{
    size_t total_received = 0;  // 已接收字节数
    ssize_t bytes_received = 0; // 每次调用 recv 接收到的字节数

    while (total_received < len)
    {
        bytes_received = recv(sock, (char *)buf + total_received, len - total_received, 0);
        if (bytes_received < 0)
        {
            if (errno == EINTR)
            {
                // 如果是EINTR错误，继续尝试接收
                continue;
            }
            else
            {
                perror("Error in recv");
                return -1; // 接收失败
            }
        }
        else if (bytes_received == 0)
        {
            fprintf(stderr, "Connection closed by peer\n");
            return 0; // 对端关闭连接
        }
        total_received += bytes_received; // 累计已接收字节数
    }

    return 1; // 成功接收完整数据
}
// 生成会话标识符
void generate_session_id(char *session_id)
{
    const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz123456789&*%$#*)(*:)";

    unsigned int charset_size = sizeof(charset);

    for (int i = 0; i < 64; i++)
    {
        int random_index = rand() % charset_size;
        session_id[i] = charset[random_index];
    }

    session_id[63] = '\0'; // 确保字符串以 NULL 结尾
}
// 发送错误消息,也用来发送其他消息
void send_message(int sockfd, const char *feedback)
{
    FeedbackMessage response;
    response.length = htonl(sizeof(response));
    response.request_code = htonl(RESPONSE_MESSAGE);
    strncpy(response.message, feedback, sizeof(response.message) - 1);
    // 确保字符串以 null 结尾
    response.message[sizeof(response.message) - 1] = '\0';

    // 发送响应
    send(sockfd, &response, ntohl(response.length), 0);
    return;
}

// 将在线用户从全局会话表中删除
int delete_session(const char *session)
{
    for (int i = 0; i < session_table_index; i++)
    {
        if (strcmp(session_table[i].session, session) == 0)
        {
            // 删除会话，将后续会话前移
            for (int j = i; j < session_table_index - 1; j++)
            {
                session_table[j] = session_table[j + 1];
            }
            session_table_index--;
            return 1; // 成功删除
        }
    }
    return 0; // 未找到会话
}

void send_simple(int sockfd, int success)
{
    unsigned int len_response = sizeof(SimpleResponse);
    SimpleResponse *response = (SimpleResponse *)malloc(len_response);
    response->length = htonl(len_response);
    response->request_code = htonl(SIMPLE_RESPONSE);
    if (success == SUCCESS)
    {
        response->status_code = htonl(SUCCESS);
        send(sockfd, response, len_response, 0);
        free(response);
        return;
    }
    response->status_code = htonl(FAIL);
    send(sockfd, response, len_response, 0);
    free(response);
    return;
}

// 用户上线推送好友列表
void push_fri_list(char **list, int count, int client_fd, MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;
    char fri_list[255] = "好友列表：\n";
    int friend_id;
    for (int i = 0; i < count; i++)
    {
        strncat(fri_list, list[i], MAX_USERNAME_LENGTH - 1); // 拼接好友用户名
        friend_id = find_id_mysql(list[i], conn);
        snprintf(query, sizeof(query), "select alias from friend_aliases where user_id=%d and friend_id=%d;", client_session.id, friend_id);
        printf("%s\n",query);
        result = do_query(query, conn);
        row = mysql_fetch_row(result);
        int row_num = mysql_num_rows(result);
        if (result != NULL && row_num > 0)
        {
            strcat(fri_list, "(");
            strcat(fri_list, row[0]);
            strcat(fri_list, ")");
            mysql_free_result(result);
        }
        strncat(fri_list, ":", 1);
        int found = 0; // 标志变量，初始值为未找到
        for (int j = 0; j < session_table_index; j++)
        {
            if (strcmp(session_table[j].username, list[i]) == 0)
            {
                strncat(fri_list, " online", 16);
                found = 1;
                break;
            }
        }
        if (!found)
        {
            strncat(fri_list, " offline", 16); // 添加 "offline" 到字符串末尾
        }
        strncat(fri_list, "\n", 1);
    }
    send_message(client_fd, fri_list); // 发送给客户端
    return;
}
// 发送私聊消息
void private_message(int client, char *buffer, MYSQL *conn)
{
    PrivateMessage *message = (PrivateMessage *)buffer;
    int recver_fd;
    int online = 0;
    int i = 0;
    for (i; i < session_table_index; i++)
    {
        if (strcmp(session_table[i].username, message->receiver_username) == 0)
        {
            online = 1;
            recver_fd = session_table[i].client_fd;
        }
    }
    i = find_session_index(0, message->session_token);

    char send_online[512];
    snprintf(send_online, sizeof(send_online), "%s:%s", session_table[i].username, message->message);

    // 在线直接发送，否则插入到数据库
    if (online)
    {
        send_message(recver_fd, send_online);
        return;
    }

    int sender_id = find_uid(message->session_token);
    int recver_id = find_id_mysql(message->receiver_username, conn);

    char query[512];
    snprintf(query, sizeof(query), "INSERT INTO offline_messages (sender_id,receiver_id,message) "
                                   "VALUES ('%d', '%d','%s');",
             sender_id, recver_id, message->message);
    do_query(query, conn);

    return;
}

MYSQL_RES *do_query(char *query, MYSQL *conn)
{
    if (mysql_query(conn, query))
    {
        fprintf(stderr, "Query Error: %s\n", mysql_error(conn));
        return NULL;
    }

    if (mysql_field_count(conn) == 0)
    {
        // Query did not return a result set
        my_ulonglong affected_rows = mysql_affected_rows(conn);
        if (affected_rows == (my_ulonglong)-1)
        {
            fprintf(stderr, "Error fetching affected rows: %s\n", mysql_error(conn));
        }
        else
        {
            printf("Query OK, %llu rows affected\n", affected_rows);
        }
        return NULL;
    }

    MYSQL_RES *result = mysql_store_result(conn);
    if (result == NULL)
    {
        fprintf(stderr, "Store Result Error: %s\n", mysql_error(conn));
        return NULL;
    }

    return result;
}
// 用户上线时获取在线好友列表
char **get_online_friends(char **friends, int *friend_count, int *online_friend_count)
{
    int i, j, k = 0;                                                    // k用于新数组索引
    char **new_friends = (char **)malloc(sizeof(char *) * MAX_FRIENDS); // 新的动态数组

    for (i = 0; i < MAX_FRIENDS; i++)
    {
        new_friends[i] = (char *)malloc(MAX_USERNAME_LENGTH * sizeof(char));
    }

    for (i = 0; i < *friend_count; i++)
    {
        for (j = 0; j < session_table_index; j++)
        {
            if (strcmp(friends[i], session_table[j].username) == 0)
            {
                strcpy(new_friends[k], friends[i]);
                k++;
                break; // 匹配上了直接跳出内层循环
            }
        }
    }

    *online_friend_count = k;
    return new_friends;
}
// 从数据库中获取用户好友列表
char **get_friend_list(int user_id, int *friend_count, MYSQL *conn)
{
    // 分配结果数组
    char **friend_list = malloc(MAX_FRIENDS * sizeof(char *));
    for (int i = 0; i < MAX_FRIENDS; i++)
    {
        friend_list[i] = malloc(MAX_USERNAME_LENGTH * sizeof(char));
    }
    MYSQL_RES *res;
    MYSQL_ROW row;
    // 初始化计数
    *friend_count = 0;

    // 构建 SQL 查询
    char query[512];
    snprintf(query, sizeof(query),
             "SELECT u.username AS friend_username "
             "FROM friends f "
             "JOIN users u "
             "ON (f.friend_id = u.id AND f.user_id = %d AND f.status = 'accepted') "
             "OR (f.user_id = u.id AND f.friend_id = %d AND f.status = 'accepted');",
             user_id, user_id);

    res = do_query(query, conn);

    if (res == NULL)
    {
        fprintf(stderr, "mysql_store_result() failed: %s\n", mysql_error(conn));

        exit(EXIT_FAILURE);
    }

    // 解析结果
    while ((row = mysql_fetch_row(res)))
    {
        if (*friend_count >= MAX_FRIENDS)
            break; // 防止超出数组范围

        // 将用户名复制到结果数组中
        strncpy(friend_list[*friend_count], row[0], MAX_USERNAME_LENGTH);
        (*friend_count)++;
    }

    // 释放资源
    mysql_free_result(res);

    return friend_list;
}

// 上下线推送消息给在线好友
void on_off_push(int on)
{

    Event event;
    memset(&event, 0, sizeof(Event));
    event.event_type = on ? 111 : 222; // 111 = 上线, 222 = 下线
    strncpy(event.username, client_session.username, MAX_USERNAME_LENGTH);
    char online_push[128];
    memset(online_push, 0, sizeof(online_push));
    strcat(online_push, client_session.username);
    if (on == 1)
    {
        strcat(online_push, "已上线！");
    }
    else
    {
        strcat(online_push, "已下线！");
    }

    int i;
    if (online_friends)
    {
        // 遍历并处理在线好友
        for (i = 0; i < online_friend_count; i++)
        {
            int index = find_session_index(1, online_friends[i]);
            if (index == -1)
            {
                continue;
            }
            send_message(session_table[index].client_fd, online_push); // 向好友客户端发送上线消息

            EventQueue *queue = find_queue(session_table[index].client_fd); // 向好友服务器进程的事件队列中插入上线事件
            push_event(queue, event);
        }
        return;
    }
}
// 离线消息推送
void offline_message_push(unsigned int user_id, MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;
    snprintf(query, sizeof(query),
             "SELECT u.username AS sender, om.message, om.created_at "
             "FROM offline_messages om "
             "JOIN users u ON om.sender_id = u.id "
             "WHERE om.receiver_id = '%d'; ",
             user_id);
    result = do_query(query, conn);
    int num_rows = (int)mysql_num_rows(result);
    if (num_rows == 0)
    {
        return;
    }
    char message[1024];
    while ((row = mysql_fetch_row(result)))
    {
        strcat(message, row[0]);
        strcat(message, ":");
        strcat(message, row[1]);
        strcat(message, "\n");
    }
    mysql_free_result(result);
    send_message(client_session.client_fd, message);
    snprintf(query, sizeof(query), "delete from offline_messages where receiver_id='%u'", user_id);
    do_query(query, conn);
    return;
}
// 检查用户是否在线
int online_query(char *name)
{
    int i = 0;
    for (i; i < session_table_index; i++)
    {
        if (strcmp(session_table[i].username, name) == 0)
        {
            return 1;
        }
    }
    return 0;
}

// 根据会话标识符找到在线用户id
int find_uid(char *token)
{

    int i = find_session_index(0, token);
    int id = session_table[i].id;
    return id;
}
// 根据会话标识符找到在线用户在全局会话表中的索引
int find_session_index(int search_by, const char *value)
{
    for (int i = 0; i < session_table_index; i++)
    {
        if (search_by == 0)
        { // 按 session 字段查找
            if (strcmp(session_table[i].session, value) == 0)
            {
                return i;
            }
        }
        else if (search_by == 1)
        { // 按 username 字段查找
            if (strcmp(session_table[i].username, value) == 0)
            {
                return i;
            }
        }
    }
    return -1; // 如果未找到匹配项，返回 -1
}

// 从数据库中根据用户名查找用户id
int find_id_mysql(char *name, MYSQL *conn)
{
    char query[512];
    MYSQL_RES *result;
    MYSQL_ROW row;
    snprintf(query, sizeof(query), "SELECT id FROM users WHERE username='%s'", name);
    result = do_query(query, conn);
    row = mysql_fetch_row(result);
    int id = atoi(row[0]);
    mysql_free_result(result);
    return id;
}

void clietn_exit(pthread_t *event_pthread, event_pthread_arg *event_arg, int client_fd, MYSQL *conn)
{
    on_off_push(0);

    pthread_mutex_lock(&client_queues_lock);
    delete_client_map(client_session.client_fd);
    pthread_mutex_unlock(&client_queues_lock);
    stop_event_queue(queue);
    destroy_event_queue(queue);

    delete_session(client_session.session);

    pthread_cancel(*event_pthread);
    free(event_arg);
    free(event_pthread);
    free(queue);
    free_friend_list(friends);
    free_friend_list(online_friends);
    mysql_close(conn);

    close(client_fd);
    pthread_cancel(pthread_self());
}

int delete_client_map(int client_fd)
{

    for (int i = 0; i < map_index; i++)
    {
        if (clientfd_queues_map[i].client_fd == client_fd)
        {
            for (int j = i; j < map_index; j++)
            {
                clientfd_queues_map[j] = clientfd_queues_map[j + 1];
            }
            map_index--;
            return 1;
        }
    }
    return 0;
}

void free_friend_list(char **friend_list)
{
    if (friend_list == NULL)
    {
        return;
    }

    for (int i = 0; i < MAX_FRIENDS; i++)
    {
        if (friend_list[i] != NULL)
        {
            free(friend_list[i]);  // 释放每一行分配的内存
            friend_list[i] = NULL; // 将释放后的指针设置为 NULL
        }
    }
    free(friend_list);  // 释放整个数组
    friend_list = NULL; // 将释放后的指针设置为 NULL
}




server.h
#ifndef SERVER_H
#define SERVER_H
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <mysql/mysql.h>
#include <arpa/inet.h>
#include <sys/time.h> // 用于设置套接字超时
#include <pthread.h>
#include <signal.h>
#define PORT 10005
#define FILE_TRANSFER_PORT 10007
#define MAX_CLIENT 100
#define TOKEN_LEN 64
#define MAX_FRIENDS 10
#define MAX_USERNAME_LENGTH 32
#define MAX_CLIENTS 10
#define QUEUE_SIZE 10
#define MAX_MEMBERS 10

struct session_name
{
    char session[64];
    char username[32];
    int client_fd;
    unsigned id;
};
extern __thread pthread_mutex_t friend_lock;
extern __thread struct session_name client_session; // 线程局部变量存储客户端会话信息
extern __thread char **friends;
extern __thread char **online_friends; // 在线好友列表与好友列表和对应的好友数量
extern __thread int friend_count;
extern __thread int online_friend_count;

typedef struct
{
    unsigned int group_id;
    char group_name[32];
    char members[MAX_MEMBERS][MAX_USERNAME_LENGTH];
    int member_count;
} Group;
extern Group groups[10];
// 以下三个结构体用于事件队列机制，实现上下线消息的及时推送
typedef struct
{
    int event_type;                     // 1 = 上线通知, 0 = 下线通知
    char username[MAX_USERNAME_LENGTH]; // 好友用户名
} Event;

typedef struct
{
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    Event events[QUEUE_SIZE]; // 固定大小的事件数组
    int head;                 // 队列头部索引
    int tail;                 // 队列尾部索引
    int count;
    int stop;                // 队列中的事件数
} EventQueue;
// 存储每个客户端文件描述符和其事件队列的映射关系
typedef struct
{
    int client_fd;
    EventQueue *queue;
} ClientEventQueueMap;

typedef struct
{
    EventQueue *queue;
    char **online_friends;
    char **friends;
    int *friend_count;
    int *online_friend_count;
} event_pthread_arg;

// 使用 extern 关键字声明全局变量
extern struct session_name session_table[10];
extern int session_table_index;
extern ClientEventQueueMap clientfd_queues_map[MAX_CLIENTS]; // 存储客户端事件队列与描述符号的映射
extern pthread_mutex_t client_queues_lock;
extern int map_index;
extern char online_members[MAX_MEMBERS][MAX_USERNAME_LENGTH];
extern int file_sock;

// 请求码定义
#define REQUEST_LOGIN 10001
#define RESPONSE_LOGIN 10021
#define REQUEST_LOGOUT 10002
#define REQUEST_ADD_FRIEND 10003
#define REQUEST_HANDELE_ADD 10011
#define REQUEST_DELETE_FRIEND 10004
#define REQUEST_FRIEND_REMARK 10033


#define REQUEST_INVITE_TOGROUP 10013
#define REQUEST_CREATE_GROUP 10006
#define REQUEST_HANDLE_GROUP 10031
#define REQUEST_GROUP_MESSAGE 10007
#define  REQUEST_GROUPNAME_RESET 10032

#define REQUEST_PRIVATE_MESSAGE 10008

#define REQUEST_FILE_TRANSFER 10009
#define RESPONSE_FILE_TRANSFER 10016
#define RESPONSE_FILE_ACK 10017
#define REQUEST_CREATEUSER 10010
#define REQUEST_POLLING 10012


#define CLIENT_EXIT 10000

#define RESPONSE_MESSAGE 10040
#define SIMPLE_RESPONSE 10050
#define SUCCESS 200
#define FAIL 500
#define BUFSIZE 4096
typedef struct
{
    unsigned int length;
    unsigned int request_code; // 请求码
    char message[2048];
} FeedbackMessage;

// 登录请求结构体
typedef struct
{
    unsigned int length;
    unsigned int request_code; // 请求码
    char username[32];
    char password[32];
} LoginRequest;

// 创建用户请求结构体
typedef struct
{
    unsigned int length;
    unsigned int request_code;
    char username[32];
    char password[32];
} CreateUser;

// 登录响应结构体
typedef struct
{
    unsigned int length;
    unsigned int request_code;
    unsigned int status_code;    // 200=成功, 401=认证失败
    char session_token[64];      // 会话标识符
    char offline_messages[1024]; // 离线消息
} LoginResponse;

// 添加/删除好友请求结构体
typedef struct
{
    unsigned int length;
    unsigned int request_code; // 请求码
    char session_token[64];
    char friend_username[32];
    unsigned int action; // 1=添加好友, 0=删除好友
} FriendRequest;

// 处理好友请求
typedef struct
{
    unsigned int length;
    unsigned int request_code; // 请求码
    unsigned int action;       // 1 接受，0拒绝
    char friend_username[32];
    char session_token[64]; // 会话标识符
} HandleFriendRequest;

// 响应用简单的回复报文
typedef struct
{
    unsigned int length;
    unsigned int request_code;
    unsigned int status_code; // 200=成功,  500=失败
} SimpleResponse;

// 好友备注请求结构体
typedef struct
{
    unsigned int length;
    unsigned int request_code; // 请求码
    char session_token[64];
    char friendname[32];
    char remark[32]; // 好友备注
} FriendRemarkRequest;
// 响应用简单的回复报文

// 创建群组,处理群聊请求，请求结构体
typedef struct
{
    unsigned int length;
    unsigned int request_code;
    int action;
    char session_token[64];
    char group_name[64];
} GroupCreateRequest, HandleGroupInvite;
// 邀请好友进群的结构体
typedef struct
{
    unsigned int length;
    unsigned int request_code;
    int action;
    char friendname[32];
    char session_token[64];
    char group_name[64];
} InviteRequest;
// 群组消息广播结构体
typedef struct
{
    unsigned int length;
    unsigned int request_code; // 请求码
    unsigned int group_id;
    char session_token[64];
    char message[256];
} GroupMessage;

typedef struct
{
    unsigned int length;
    unsigned int request_code; // 请求码
    unsigned int group_id;
    char group_newname[64];
} GroupNameRestet;

typedef struct
{
    unsigned int length;
    unsigned int status_code; // 200=成功, 500=失败
    char group_id[64];        // 创建成功的群组ID
} GroupCreateResponse;

// 点对点消息结构体
typedef struct
{
    unsigned int length;
    unsigned int request_code; // 请求码
    char session_token[64];
    char receiver_username[32];
    char message[256];
} PrivateMessage;

// 响应用简单的回复报文

// 文件传输请求结构体
typedef struct
{
    unsigned int length;
    unsigned int request_code; // 请求码
    unsigned int file_size;
    char receiver_username[32];
    char session_token[64];
    char file_name[128];
} FileTransferRequest;

typedef struct
{
    unsigned int length;
    unsigned int request_code;  //ack
    unsigned int block_number;  //分块编号
} FileTransferResponse;
    typedef struct {
    int num_files;
    char **offline_file;
} OfflineFileData;

typedef struct
{
    unsigned int length;
    unsigned int request_code; // 请求码
    char token[64];            // 用于后续传输
} Polling;

// 初始化服务器套接字
int init_server();

// 处理客户端请求
void *handle_client(void *arg);

// 登录功能处理
void handle_login(int client_fd, char *buffer, MYSQL *conn, pthread_t *queue_pthread,event_pthread_arg *event_arg);
// 添加好友处理
void handle_add_friend(int client_fd, char *buffer, MYSQL *conn);
// 创建用户处理
void handle_create_user(int client_fd, char *buffer, MYSQL *conn);
// 处理好友请求
void handle_accept_add(int client_fd, char *buffer, MYSQL *conn);
// 数据库连接
MYSQL *db_connect();

// 存储会话标识符与用户名的映射
void store_session(const char *username, const char *session_token, unsigned int id, int client_fd);
// 推送好友
void push_friend(int client_fd, char *username, MYSQL *conn);
// 错误反馈
void send_message(int sockfd, const char *feedback);

// 从数据库中获取好友列表
char **get_friend_list(int user_id, int *friend_count, MYSQL *conn);
// 生成会话标识符
void generate_session_id(char *session_id);

// 推送好友列表
void push_fri_list(char **list, int count, int client_fd, MYSQL *conn);

int recv_full(int sock, void *buf, size_t len);
// 根据会话标识符找到用户在表中的索引
int find_session_index(int search_by, const char *value);
// 将一个会话从表中删除
int delete_session(const char *session);
void send_simple(int sockfd, int success);
// 获取在线用户的id
int find_uid(char *token);

void private_message(int client, char *buffer, MYSQL *conn);

MYSQL_RES *qurey(char *query, MYSQL *conn); // 执行一个查询语句，返回结果集合
int init_file_transfer_server() ;
int find_id_mysql(char *name, MYSQL *conn); // 获取离线用户的id
char **get_online_friends(char **friends, int *friend_count, int *online_friend_count);

void offline_message_push(unsigned int user_id, MYSQL *conn);
void on_off_push(int on);
void create_group(int client_fd, char *buffer, MYSQL *conn);
int online_query(char *friendname);
void invite_to_group(int client_fd, char *buffer, MYSQL *conn);
MYSQL_RES *do_query(char *query, MYSQL *conn);

EventQueue *init_event_queue();
int push_event(EventQueue *queue, Event event);
int pop_event(EventQueue *queue, Event *event);
void init_client_queues();
void cleanup_client_queues();
EventQueue *find_queue(int client_fd);
void *process_events(void *arg);
void update_online_friends(Event *event, event_pthread_arg *event_arg);
void group_invite_push(int client_fd, MYSQL *conn);
int find_group_id(char *groupname, MYSQL *conn);
void handle_add_group(int client_fd, char *buffer, MYSQL *conn);
void group_message(int client_fd, char *buffer, MYSQL *conn);
int get_groupnum(MYSQL *conn);
void online_groupmembers(Group *groups, int group_id, char (*members)[MAX_USERNAME_LENGTH]);

// 声明获取群组成员的函数
void get_groupmember(Group *groups, MYSQL *conn);
void users_group_query(int client_fd,int user_id, MYSQL *conn);
// 声明向群组添加成员的函数
int add_member_to_group(Group *groups, unsigned int group_id, const char *username);

// 声明从群组中移除成员的函数
int remove_member_from_group(Group *groups, unsigned int group_id, const char *username);

// 声明添加新群组的函数
int add_group(Group *groups, unsigned int group_id, const char *group_name);
// 声明解散群组的函数
int dissolve_group(Group *groups, unsigned int group_id);
void print_groups(Group *groups, MYSQL *conn);

void groupname_reset(int client_fd,char *buffer,MYSQL *conn);

void offline_file_push(int client_fd, char *buffer, MYSQL *conn);
void file_transfer(int client_fd, char *filename);
void file_recv(int client_fd, char *buffer, MYSQL *conn);

void clietn_exit(pthread_t *event_pthread, event_pthread_arg *event_arg, int client_fd, MYSQL *conn);

OfflineFileData *offline_file_query(int recver_id, MYSQL* conn);
long get_file_size(const char *filename);
void free_offline_file(OfflineFileData *data);
void filetransfer_req(int client_fd,char *filename);

int delete_client_map(int client_fd);
void free_friend_list(char **friend_list);
void destroy_event_queue(EventQueue *queue);
void stop_event_queue(EventQueue *queue);
void friend_remark(int client_fd, char *buffer, MYSQL *conn);
#endif



